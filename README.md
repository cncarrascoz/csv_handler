# gRPC CSV Handler

## 1. Project Overview

This project implements a client-server system in C++ using gRPC and Protocol Buffers. The primary goal is to allow a client application to send CSV data to a server, where the server parses the data and stores it efficiently in memory using a column-store format. The system is designed with modularity in mind, anticipating future expansion into a distributed architecture.

## 2. Architecture

- **Client-Server Model:** A standard client-server architecture where the client initiates requests and the server responds.
- **Communication:** gRPC is used for defining the service interface (`proto/csv_service.proto`) and handling remote procedure calls between the client and server. Protocol Buffers are used for serializing the data structures (like the CSV content and file lists).
- **Data Storage:** The server currently stores the parsed CSV data entirely in memory. To optimize for potential analytical queries, the data is stored in a column-oriented format (e.g., a map where keys are filenames and values represent columns, each column being a vector of strings).

## 3. Dependencies

To build and run this project, you need:

- **C++ Compiler:** A modern C++ compiler supporting C++11 or later (e.g., GCC, Clang).
- **CMake:** Version 3.10 or higher for building the project.
- **gRPC:** The gRPC library and its dependencies (including Protocol Buffers). Installation instructions can be found at [grpc.io](https://grpc.io/docs/languages/cpp/quickstart/).
- **Protocol Buffers:** Version 3.x or higher (usually installed as part of gRPC).

*Note: The specific versions required might depend on your system setup. Ensure compatibility between gRPC and Protobuf.* 

## 4. Directory Structure

```
csv_handler/
├── build/          # Build directory (created by CMake)
├── client/
│   ├── csv_client.cpp # Client logic implementation
│   ├── csv_client.hpp # Client class header
│   └── main.cpp       # Client executable entry point (handles args, interactive mode)
├── proto/
│   ├── csv_service.proto     # Service definition
│   ├── csv_service.pb.cc     # Generated Protobuf C++ source
│   ├── csv_service.pb.h      # Generated Protobuf C++ header
│   ├── csv_service.grpc.pb.cc # Generated gRPC C++ source
│   └── csv_service.grpc.pb.h # Generated gRPC C++ header
├── server/
│   ├── network/
│   │   ├── csv_service_impl.cpp # Server RPC implementation
│   │   └── csv_service_impl.hpp # Server RPC class header
│   └── main.cpp       # Server executable entry point
├── storage/
│   ├── csv_parser.cpp # Logic for parsing CSV data
│   └── csv_parser.hpp # Header for CSV parser
├── utils/
│   ├── file_utils.cpp # File reading utilities
│   └── file_utils.hpp # Header for file utilities
├── CMakeLists.txt     # CMake build configuration
├── mock_data.csv      # Example CSV file
└── README.md          # This file
```

- **`client/`**: Contains the gRPC client implementation responsible for connecting to the server and sending requests (upload, list).
- **`server/`**: Contains the gRPC server implementation, including the service logic (`network/`) and the main server executable.
- **`storage/`**: Holds the logic for parsing CSV strings (`csv_parser.cpp`) and potentially other data storage related functionalities.
- **`proto/`**: Contains the Protocol Buffers definition file (`.proto`) and the C++ source files generated by `protoc` and the gRPC plugin. *Note: Currently, these generated files must be created manually before running CMake (see Build Instructions)*.
- **`utils/`**: Contains general-purpose helper functions, like file reading utilities.
- **`build/`**: Directory where CMake performs the build. Not part of the source control.
- **`CMakeLists.txt`**: Defines how to build the project using CMake.

## 5. Build Instructions

1.  **Generate Protocol Buffer Files:**
    *   Navigate to the project root directory (`csv_handler/`).
    *   Ensure `protoc` and `grpc_cpp_plugin` are in your PATH or provide full paths.
    *   Run the following command:
        ```bash
        protoc --proto_path=. --cpp_out=./proto --grpc_out=./proto --plugin=protoc-gen-grpc=$(which grpc_cpp_plugin) proto/csv_service.proto
        ```
    *   This will generate the `.pb.h`, `.pb.cc`, `.grpc.pb.h`, and `.grpc.pb.cc` files inside the `proto/` directory.

2.  **Configure with CMake:**
    *   Create a build directory and navigate into it:
        ```bash
        mkdir build
        cd build
        ```
    *   Run CMake to configure the project:
        ```bash
        cmake ..
        ```

3.  **Compile:**
    *   From the `build` directory, run `make`:
        ```bash
        make
        ```
    *   This will create the `server` and `client` executables in the `build` directory.

## 6. Running the Application

1.  **Start the Server:**
    *   From the `build` directory, run:
        ```bash
        ./server
        ```
    *   The server will start listening on `localhost:50051` (or the configured address) and print a confirmation message.

2.  **Run the Client:**
    *   The client can be run in two modes from the `build` directory.
    *   **Command-Line Mode:**
        *   Upload a file:
            ```bash
            # Assumes mock_data.csv is in the parent directory
            ./client localhost:50051 upload ../mock_data.csv 
            ```
        *   List loaded files:
            ```bash
            ./client localhost:50051 list
            ```
    *   **Interactive Mode:**
        *   Start the client with only the server address:
            ```bash
            ./client localhost:50051
            ```
        *   You will be prompted with a menu:
            ```
            Entered interactive mode.
            
            Client commands:
            1. upload <filename> - Upload a CSV file
            2. list              - List loaded files on server
            3. exit              - Exit client
            > 
            ```
        *   Enter commands like `upload ../mock_data.csv`, `list`, or `exit`.

## 7. Example CSV Format

The server expects standard CSV format. The current parser handles simple cases:

```csv
Header1,Header2,Header3
Value1A,Value1B,Value1C
Value2A,Value2B,Value2C
```

- The first line is treated as headers.
- Subsequent lines are data rows.
- Values are separated by commas.
- The current parser (`storage/csv_parser.cpp`) might have limitations regarding quoted fields, escaped commas, or varying line endings. Refer to its implementation for specifics.

## 8. Server Internals: Parsing and Storage

When the client sends a CSV file via the `UploadCsv` RPC:

1.  **Reception:** The `CsvServiceImpl::UploadCsv` method on the server receives the filename and the CSV data as a string.
2.  **Parsing:** It uses the `csv_parser::parse_csv` function (from `storage/csv_parser.cpp`) to process the raw CSV string.
3.  **Columnar Conversion:** The parser returns the data in a row-oriented format (e.g., `std::vector<std::vector<std::string>>`). The `CsvServiceImpl` then likely transposes this data into a column-oriented structure.
4.  **In-Memory Storage:** The columnar data is stored in an in-memory map within the `CsvServiceImpl` instance (e.g., `std::unordered_map<std::string, std::vector<std::vector<std::string>>> data_store_`), keyed by the original filename.

This column-store format is chosen because it's often more efficient for analytical queries that typically operate on specific columns rather than entire rows.

The `ListLoadedFiles` RPC simply returns the keys (filenames) present in the `data_store_` map.

## 9. Future Distributed Version

The current modular structure (separating client, server, storage, utils) is designed to facilitate future expansion into a distributed system. Potential future components include:

- **Coordinator Node:** Manages cluster state, client requests, and distributes tasks to worker nodes.
- **Worker Nodes:** Store partitions of the data and execute parts of queries or processing tasks.
- **Replication:** Implement data replication across worker nodes for fault tolerance.
- **Heartbeat Mechanism:** Allow nodes to monitor each other's status.

The current single-server implementation serves as the foundation for these components.
